using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Kontur.Elba.Aop.Definitions.ChangeTracking;
using Kontur.Elba.Aop.Rewriter.MonoCecil;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;

namespace Kontur.Elba.Aop.Rewriter.ChangeTracking
{
	public class ChangeTrackingTypeWeaver
	{
		private readonly TypeReference trackableTypeReference;
		private readonly MethodReference changeTrackerConstructor;
		private readonly TypeReference changeTrackerTypeReference;
		private readonly MethodReference beforeTargetPropertyChange;
		private readonly MethodReference rewrittenForTrackChangesAttribute;
		private readonly TypeReference initializeTrackableTypeReference;

		public ChangeTrackingTypeWeaver(AssemblyDefinition targetAssembly)
		{
			trackableTypeReference = targetAssembly.MainModule.Import(typeof (ITrackable));
			initializeTrackableTypeReference = targetAssembly.MainModule.Import(typeof (IInitializeTrackable));
			changeTrackerTypeReference = targetAssembly.MainModule.Import(typeof (ChangeTracker));
			changeTrackerConstructor = targetAssembly.MainModule.Import(typeof (ChangeTracker).GetConstructors()[0]);
			beforeTargetPropertyChange = targetAssembly.MainModule.Import(typeof (ChangeTracker).GetMethod("BeforeTargetPropertyChange"));
			rewrittenForTrackChangesAttribute = targetAssembly.MainModule.Import(typeof (RewrittenForTrackChangesAttribute)
				                                                                     .GetConstructor(Type.EmptyTypes));
		}

		public void MarkAsRewritten(TypeDefinition type)
		{
			type.CustomAttributes.Add(new CustomAttribute(rewrittenForTrackChangesAttribute));
		}

		private static bool IsAutogenerated(MethodDefinition method)
		{
			return method != null && method.IsPublic && method.HasAttribute<CompilerGeneratedAttribute>();
		}

		public bool TryObserveProperty(PropertyDefinition propertyDefinition, FieldReference trackerFieldReference)
		{
			var setMethod = propertyDefinition.SetMethod;
			if (!IsAutogenerated(setMethod) || !IsAutogenerated(propertyDefinition.GetMethod))
				return false;
			var instructions = setMethod.Body.Instructions;
			var backingFields = instructions
				.Where(x => x.OpCode == OpCodes.Stfld)
				.Select(x => x.Operand)
				.Cast<FieldDefinition>()
				.ToArray();
			if (backingFields.Length != 1)
				return false;
			var newInstructions = new List<Instruction>
				{
					Instruction.Create(OpCodes.Ldarg_0),
					Instruction.Create(OpCodes.Ldfld, trackerFieldReference),
					Instruction.Create(OpCodes.Ldarg_0),
					Instruction.Create(OpCodes.Ldfld, backingFields[0])
				};
			var propertyHasValueType = propertyDefinition.PropertyType.IsValueType;
			if (propertyHasValueType)
				newInstructions.Add(Instruction.Create(OpCodes.Box, propertyDefinition.PropertyType));
			newInstructions.Add(Instruction.Create(OpCodes.Ldarg_1));
			if (propertyHasValueType)
				newInstructions.Add(Instruction.Create(OpCodes.Box, propertyDefinition.PropertyType));
			newInstructions.Add(Instruction.Create(OpCodes.Call, beforeTargetPropertyChange));
			setMethod.Body.Instructions.Prepend(newInstructions);
			return true;
		}

		public FieldDefinition ImplementTrackable(TypeDefinition typeDefinition)
		{
			var backingField = new FieldDefinition("__tracker", FieldAttributes.Family | FieldAttributes.SpecialName, changeTrackerTypeReference)
				{
					DeclaringType = typeDefinition
				};
			typeDefinition.Fields.Add(backingField);

			var initializeTrackableMethod = new MethodDefinition("InitializeTrackable",
			                                                     MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName |
			                                                     MethodAttributes.Virtual | MethodAttributes.NewSlot,
			                                                     typeDefinition.Module.TypeSystem.Void)
				{
					HasThis = true,
					DeclaringType = typeDefinition
				};
			var il = initializeTrackableMethod.Body.GetILProcessor();
			il.Emit(OpCodes.Ldarg_0);
			il.Emit(OpCodes.Ldarg_0);
			il.Emit(OpCodes.Newobj, changeTrackerConstructor);
			il.Emit(OpCodes.Stfld, backingField);
			il.Emit(OpCodes.Ret);
			typeDefinition.Methods.Add(initializeTrackableMethod);

			foreach (var ctorInstructions in typeDefinition.GetConstructors().Where(x => !x.IsStatic).Select(c => c.Body.Instructions))
				for (var i = 0; i < ctorInstructions.Count; i++)
				{
					var ctorInstruction = ctorInstructions[i];
					if (ctorInstruction.OpCode != OpCodes.Call)
						continue;
					var method = ((MethodReference) ctorInstruction.Operand).Resolve();
					if (!method.IsConstructor)
						continue;
					if (method.DeclaringType.FullName != typeDefinition.FullName)
					{
						ctorInstructions.Insert(i + 1, Instruction.Create(OpCodes.Ldarg_0));
						ctorInstructions.Insert(i + 2, Instruction.Create(OpCodes.Callvirt, initializeTrackableMethod));
					}
					break;
				}

			var getTrackerMethod = new MethodDefinition("get_Tracker",
			                                            MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName |
			                                            MethodAttributes.Virtual | MethodAttributes.NewSlot,
			                                            changeTrackerTypeReference)
				{
					HasThis = true,
					DeclaringType = typeDefinition
				};
			var getTrackerMethodInstructions = getTrackerMethod.Body.Instructions;
			getTrackerMethodInstructions.Add(Instruction.Create(OpCodes.Ldarg_0));
			getTrackerMethodInstructions.Add(Instruction.Create(OpCodes.Ldfld, backingField));
			getTrackerMethodInstructions.Add(Instruction.Create(OpCodes.Ret));
			typeDefinition.Methods.Add(getTrackerMethod);
			typeDefinition.Interfaces.Add(trackableTypeReference);
			typeDefinition.Interfaces.Add(initializeTrackableTypeReference);
			return backingField;
		}
	}
}